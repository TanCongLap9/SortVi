{
  "api": [
    {
      "name": "Color",
      "type": "enum",
      "desc": "Color used for highlighting.",
      "values": [
        {
          "name": "RED",
          "value": "bar-red"
        },
        {
          "name": "GREEN",
          "value": "bar-green"
        },
        {
          "name": "BLUE",
          "value": "bar-blue"
        }
      ]
    },
    {
      "name": "BarGraph",
      "type": "class",
      "desc": "Represents a visual graph for a main array or auxiliary array. You can retrieve element value or set its element to a new value like you do with normal arrays. If set, the change will also be reflected in the graph."
    },
    {
      "name": "arrays",
      "type": "object",
      "entityType": "Array<BarGraph>",
      "desc": "Contains one or more bar graphs, with the first that represents main array and the others that represent corresponding auxiliary arrays."
    },
    {
      "name": "mo_highlight",
      "type": "method",
      "desc": "Highlights one or more bars with specific color.",
      "signatures": [
        {
          "signature": "(indices: Array<number> | number, colors: Array<Color> | Color): void",
          "desc": "Highlights one or more bars in the main array with specific color."
        },
        {
          "signature": "(array: BarGraph, indices: Array<number> | number, colors: Array<Color> | Color): void",
          "desc": "Highlights one or more bars in the main array with specific color."
        },
        {
          "signature": "(params: Array<[BarGraph, Array<number> | number, Array<Color> | Color]>): void",
          "desc": "Highlights one or more bars in multiple graphs with specific color."
        }
      ],
      "examples": [
        "mo_highlight([1, 2], [RED, GREEN]);",
        "mo_highlight([3, 2], RED);",
        "mo_highlight(aux1, [3, 2], RED);",
        "mo_highlight([\n  [array, [1, 2], [RED, GREEN]],\n  [array1, [1, 2], [RED, GREEN]]\n]);",
        "mo_highlight([\n  [array, [2, 3, 4], RED],\n  [array1, [1, 2], [RED, GREEN]]\n]);"
      ]
    },
    {
      "name": "mo_swap",
      "type": "method",
      "desc": "Swaps 2 elements in the array.",
      "signatures": [
        {
          "signature": "a: number, b: number): void",
          "desc": "Swaps 2 elements in the main array."
        },
        {
          "signature": "(barGraph: BarGraph, a: number, b: number): void",
          "desc": "Swaps 2 elements in the specified array."
        }
      ]
    },
    {
      "name": "mo_auxArrays",
      "type": "method",
      "desc": "Allocate auxiliary arrays. Put this line on top of algorithm code.",
      "signatures": [
        {
          "signature": "(n: number, ...sizes: Array<number>): Array<BarGraph>",
          "desc": "Allocate auxiliary arrays, each having its size specified (or matching the main array if not) and its values set to 0. Returns auxiliary arrays."
        }
      ],
      "examples": [
        "const [l, r] = mo_auxArrays(2);",
        "const [l, r] = mo_auxArrays(2, 12, 24);"
      ]
    },
    {
      "name": "mo_mark",
      "type": "method",
      "desc": "Marks the current step that will be shown in the steps slider.",
      "signatures": [
        {
          "signature": "(): void",
          "desc": "Marks the current step that will be shown in the steps slider."
        }
      ]
    },
    {
      "name": "mo_range",
      "type": "method",
      "desc": "Generates an incremental/decremental sequence of numbers.",
      "signatures": [
        {
          "signature": "(stop: number): Array<number>",
          "desc": "Generates a incremental sequence from 0 to `stop` (exclusive)."
        },
        {
          "signature": "(start: number, stop: number, step?: number): Array<number>",
          "desc": "Generates a progressive sequence of numbers from `start` (inclusive) to `stop` (exclusive), each number optionally differentiates by `step`."
        }
      ],
      "examples": ["mo_highlight([...mo_range(1, 4)], RED);"]
    },
    {
      "name": "mo_clearArray",
      "type": "method",
      "desc": "Resets the array to 0.",
      "signatures": [
        {
          "signature": "(...array: Array<BarGraph>): void",
          "desc": "Resets the array to 0. Primarily used to simulate clean-up of auxiliary arrays."
        }
      ],
      "examples": ["mo_auxArrays(aux1, aux2);"]
    },
    {
      "name": "Math.round",
      "type": "method",
      "desc": "Rounds a number to integer or n-th place of fractional part.",
      "signatures": ["(x: number, n?: number): number"]
    },
    {
      "name": "Math.log",
      "type": "method",
      "desc": "Returns logarithm of x base b (default: e).",
      "signatures": ["(x: number, b?: number): number"]
    },
    {
      "name": "Math.clamp",
      "type": "method",
      "desc": "Limits the number into the specified range.",
      "signatures": ["(value: number, min?: number, max?: number): number"]
    }
  ],
  "sorts": [
    {
      "name": "believe",
      "code": [
        "#!iCantBelieveItCanSort",
        "function iCantBelieveItCanSort(array) {",
        "  for (let i = 0; i < array.length; i++)",
        "    for (let j = 0; j < array.length; j++) {",
        "      mo_highlight([i, j], [RED, GREEN]);",
        "      if (array[i] < array[j]) {",
        "        mo_swap(i, j);",
        "      }",
        "    }",
        "}"
      ]
    },
    {
      "name": "bitonic",
      "code": [
        "#!main",
        "function bitonicMerge(array, first, length, decreasing) {",
        "  if (length <= 1) return;",
        "  mo_highlight([...mo_range(first, first + length)], decreasing ? BLUE : GREEN);",
        "  let half = Math.floor(length / 2);",
        "  for (let i = first; i < first + half; i++) {",
        "    mo_highlight([i, i + half], RED);",
        "    if (array[i] > array[i + half] !== decreasing)",
        "      mo_swap(i, i + half);",
        "  }",
        "  bitonicMerge(array, first, half, decreasing);",
        "  bitonicMerge(array, first + half, half, decreasing);",
        "}",
        "function bitonicSort(array, first, length, decreasing) {",
        "  if (length <= 1) return;",
        "  let half = Math.floor(length / 2);",
        "  bitonicSort(array, first, half, false);",
        "  bitonicSort(array, first + half, half, true);",
        "  bitonicMerge(array, first, length, decreasing);",
        "}",
        "function main(array) {",
        "  if (!Number.isInteger(Math.log2(array.length))) {",
        "    throw new RangeError(`Expected size of array to be power of 2, got ${array.length}.`);",
        "  }",
        "  bitonicSort(array, 0, array.length, false);",
        "}"
      ]
    },
    {
      "name": "bogo",
      "code": [
        "#!bogoSort",
        "function isSorted(array) {",
        "  return array.every((_, i) => !i || array[i - 1] <= array[i]);",
        "}",
        "function bogoSort(array) {",
        "  while (!isSorted(array)) {",
        "    for (let i = array.length - 1; i > 0; i--) {",
        "      let randomIndex = Math.floor(Math.random() * (i + 1));",
        "      mo_swap(i, randomIndex);",
        "    }",
        "  }",
        "}"
      ]
    },
    {
      "name": "bozo",
      "code": [
        "#!bozoSort",
        "function isSorted(array) {",
        "  return array.every((_, i) => !i || array[i - 1] <= array[i])",
        "}",
        "function bozoSort(array) {",
        "  while (!isSorted(array)) {",
        "    let randomIndex = Math.floor(Math.random() * array.length);",
        "    let randomIndex2 = Math.floor(Math.random() * array.length);",
        "    if (randomIndex === randomIndex2) continue;",
        "    mo_swap(randomIndex, randomIndex2);",
        "  }",
        "}"
      ]
    },
    {
      "name": "bubble",
      "code": [
        "#!bubbleSort",
        "function bubbleSort(array) {",
        "  for (let i = array.length - 1; i >= 1; i--) {",
        "    mo_mark();",
        "    for (let j = 1; j <= i; j++) {",
        "      mo_highlight([j - 1, j, i], [GREEN, GREEN, BLUE]);",
        "      if (array[j - 1] > array[j])",
        "        mo_swap(j - 1, j);",
        "    }",
        "  }",
        "}"
      ]
    },
    {
      "name": "cocktail",
      "code": [
        "#!cocktailSort",
        "function bubbleSort(array, first, last, reversed) {",
        "  let changed = false;",
        "  for (let i = reversed ? last : first + 1; reversed ? i >= first + 1 : i <= last; reversed ? i-- : i++) {",
        "    mo_highlight([i - 1, i, first, last], [RED, RED, BLUE, BLUE]);",
        "    if (array[i - 1] > array[i]) {",
        "      mo_swap(i - 1, i);",
        "      changed = true;",
        "    }",
        "  }",
        "  return changed;",
        "}",
        "function cocktailSort(array) {",
        "  let changed = true, first = 0, last = array.length - 1;",
        "  while (changed) {",
        "    changed = bubbleSort(array, first, last, false);",
        "    if (!changed) break;",
        "    last--;",
        "    changed = bubbleSort(array, first, last, true);",
        "    first++;",
        "  }",
        "}"
      ]
    },
    {
      "name": "comb",
      "code": [
        "#!combSort",
        "const SHRINK = 1.3;",
        "function combSort(array) {",
        "  let gap = array.length,",
        "    sorted = false;",
        "  while (gap > 1 || !sorted) {",
        "    gap = Math.max(Math.floor(gap / SHRINK), 1);",
        "    sorted = true;",
        "    for (let i = gap; i < array.length; i++) {",
        "      mo_highlight([i - gap, i], RED);",
        "      if (array[i - gap] > array[i]) {",
        "        mo_swap(i - gap, i);",
        "        sorted = false;",
        "      }",
        "    }",
        "  }",
        "}"
      ]
    },
    {
      "name": "count",
      "code": [
        "#!main",
        "function countingSort(array, count, output) {",
        "  for (let i = 0; i < array.length; i++) {",
        "    mo_highlight(i, GREEN);",
        "    count[array[i]]++;",
        "  }",
        "  for (let i = 1; i < count.length; i++) {",
        "    count[i] += count[i - 1];",
        "  }",
        "  for (let i = array.length - 1; i >= 0; i--) {",
        "    let v = array[i];",
        "    output[--count[v]] = v;",
        "  }",
        "  for (let i = 0; i < array.length; i++) {",
        "    array[i] = output[i];",
        "  }",
        "  mo_clearArray(count, output);",
        "}",
        "function main(array) {",
        "  for (let i = 0; i < array.length; i++) {",
        "    if (!Number.isInteger(array[i]) || array[i] < 0) {",
        "      throw new RangeError(`Expected non-negative integers, got ${array[i]}.`);",
        "    }",
        "  }",
        "  let [count, output] = mo_auxArrays(2, Math.max(...array) + 1);",
        "  countingSort(array, count, output);",
        "}"
      ]
    },
    {
      "name": "cycle",
      "code": [
        "#!cycleSort",
        "function cycleSort(array) {",
        "  for (let i = 0; i < array.length - 1; i++) {",
        "    let v = array[i];",
        "    let k = i;",
        "    for (let j = i + 1; j < array.length; j++) {",
        "      mo_highlight([i, j, k], [GREEN, GREEN, BLUE]);",
        "      if (v > array[j]) k++;",
        "    }",
        "    if (k === i) continue;",
        "    while (v === array[k]) {",
        "      mo_highlight([i, k], [BLUE, BLUE]);",
        "      k++;",
        "    }",
        "    if (k !== i) {",
        "      [array[k], v] = [v, array[k]];",
        "    }",
        "    while (k !== i) {",
        "      k = i;",
        "      for (let j = i + 1; j < array.length; j++) {",
        "        mo_highlight([i, j, k], [GREEN, GREEN, RED]);",
        "        if (array[j] < v) k++;",
        "      }",
        "      while (v === array[k]) {",
        "        mo_highlight([i, k], [RED, RED]);",
        "        k++;",
        "      }",
        "      if (v !== array[k]) {",
        "        [array[k], v] = [v, array[k]];",
        "      }",
        "    }",
        "  }",
        "}"
      ]
    },
    {
      "name": "exchange",
      "code": [
        "#!exchangeSort",
        "function exchangeSort(array) {",
        "  for (let i = 0; i < array.length - 1; i++)",
        "    for (let j = i + 1; j < array.length; j++) {",
        "      mo_highlight([i, j], [BLUE, GREEN]);",
        "      if (array[i] > array[j])",
        "        mo_swap(i, j);",
        "    }",
        "}"
      ]
    },
    {
      "name": "gnome",
      "code": [
        "#!gnomeSort",
        "function gnomeSort(array) {",
        "  for (let index = 1; index < array.length;) {",
        "    mo_highlight([index - 1, index], GREEN);",
        "    if (index === 0) index++;",
        "    if (array[index - 1] <= array[index]) index++;",
        "    else {",
        "      mo_swap(index - 1, index);",
        "      index--;",
        "    }",
        "  }",
        "}"
      ]
    },
    {
      "name": "heap",
      "code": [
        "#!heapSort",
        "function heapify(array, length, i) {",
        "  let iMax = i,",
        "    first = 2 * i + 1,",
        "    last = first + 1;",
        "  if (first < length) {",
        "    mo_highlight([first, iMax], GREEN);",
        "    if (array[first] > array[iMax]) {",
        "      iMax = first;",
        "    }",
        "  }",
        "  if (last < length) {",
        "    mo_highlight([last, iMax], GREEN);",
        "    if (array[last] > array[iMax]) {",
        "      iMax = last;",
        "    }",
        "  }",
        "  if (iMax !== i) {",
        "    mo_swap(i, iMax);",
        "    heapify(array, length, iMax);",
        "  }",
        "}",
        "function heapSort(array) {",
        "  for (let i = Math.floor(array.length / 2 - 1); i >= 0; i--)",
        "    heapify(array, array.length, i);",
        "  for (let i = array.length - 1; i >= 0; i--) {",
        "    mo_highlight(i, BLUE);",
        "    mo_swap(0, i);",
        "    heapify(array, i, 0);",
        "  }",
        "}"
      ]
    },
    {
      "name": "insertion",
      "code": [
        "#!insertionSort",
        "function insertionSort(array) {",
        "  for (let i = 1; i < array.length; i++) {",
        "    mo_highlight(i, BLUE);",
        "    let j = i;",
        "    let oldValue = array[i];",
        "    for (; j > 0; j--) {",
        "      mo_highlight([j - 1, j], GREEN);",
        "      if (array[j - 1] > oldValue) {",
        "        array[j] = array[j - 1];",
        "      }",
        "      else break;",
        "    }",
        "    array[j] = oldValue;",
        "  }",
        "}"
      ]
    },
    {
      "name": "intro",
      "code": [
        "#!main",
        "function partition(arr, left, right) {",
        "  let pivot = arr[right];",
        "  let i = left - 1;",
        "  mo_highlight(",
        "    [",
        "      ...mo_range(left, right),",
        "      right,",
        "      ...mo_range(right + 1, right)",
        "    ],",
        "    [",
        "      ...mo_range(left, right).fill(RED),",
        "      BLUE,",
        "      ...mo_range(right + 1, right).fill(GREEN)",
        "    ]",
        "  );",
        "  for (let j = left; j < right; j++) {",
        "    if (arr[j] < pivot) {",
        "      i++;",
        "      mo_swap(i, j);",
        "    }",
        "  }",
        "  mo_swap(i + 1, right);",
        "  return i + 1;",
        "}",
        "function insertionSort(arr, left, right) {",
        "  for (let i = left + 1; i <= right; i++) {",
        "    mo_highlight(i, BLUE);",
        "    let j = i;",
        "    let oldValue = arr[i];",
        "    for (; j > left; j--) {",
        "      mo_highlight([j - 1, j], GREEN);",
        "      if (arr[j - 1] > oldValue) {",
        "        arr[j] = arr[j - 1];",
        "      }",
        "      else break;",
        "    }",
        "    arr[j] = oldValue;",
        "  }",
        "}",
        "function heapSort(arr, left, right) {",
        "  for (let i = Math.floor((right + left) / 2); i >= left; i--) {",
        "    heapify(arr, i, right, left);",
        "  }",
        "  for (let i = right; i > left; i--) {",
        "    mo_swap(left, i);",
        "    heapify(arr, left, i - 1, left);",
        "  }",
        "}",
        "function heapify(arr, i, length, left) {",
        "  let iMax = i,",
        "    first = 2 * i + 1 - left,",
        "    last = 2 * i + 2 - left;",
        "  if (first <= length && arr[first] > arr[iMax]) {",
        "    iMax = first;",
        "  }",
        "  if (last <= length && arr[last] > arr[iMax]) {",
        "    iMax = last;",
        "  }",
        "  if (iMax !== i) {",
        "    mo_swap(i, iMax);",
        "    heapify(arr, iMax, length, left);",
        "  }",
        "}",
        "function introsortUtil(arr, left, right, depthLimit) {",
        "  let size = right - left + 1;",
        "  if (size < 16) {",
        "    insertionSort(arr, left, right);",
        "  } else if (depthLimit === 0) {",
        "    heapSort(arr, left, right);",
        "  } else {",
        "    let pivotIndex = partition(arr, left, right);",
        "    introsortUtil(arr, left, pivotIndex - 1, depthLimit - 1);",
        "    introsortUtil(arr, pivotIndex + 1, right, depthLimit - 1);",
        "  }",
        "}",
        "function main(array) {",
        "  let maxDepth = Math.floor(Math.log2(array.length)) * 2;",
        "  introsortUtil(array, 0, array.length - 1, maxDepth);",
        "}"
      ]
    },
    {
      "name": "lsd",
      "code": [
        "#!main",
        "const BASE = 10;",
        "function digit(x, exponent) {",
        "  return Math.floor(x / exponent) % BASE;",
        "}",
        "function countingSort(array, count, output, exponent) {",
        "  for (let i = 0; i < array.length; i++) {",
        "    mo_highlight(i, GREEN);",
        "    count[digit(array[i], exponent)]++;",
        "  }",
        "  for (let i = 1; i < count.length; i++) {",
        "    count[i] += count[i - 1];",
        "  }",
        "  for (let i = array.length - 1; i >= 0; i--) {",
        "    output[--count[digit(array[i], exponent)]] = array[i];",
        "  }",
        "  for (let i = 0; i < array.length; i++) {",
        "    array[i] = output[i];",
        "  }",
        "  mo_clearArray(count, output);",
        "}",
        "function lsdSort(array, count, output) {",
        "  let max = Math.max(...array);",
        "  for (let exponent = 1; Math.floor(max / exponent) > 0; exponent *= BASE)",
        "    countingSort(array, count, output, exponent);",
        "}",
        "function main(array) {",
        "  for (let i = 0; i < array.length; i++) {",
        "    if (!Number.isInteger(array[i]) || array[i] < 0) {",
        "      throw new RangeError(`Expected non-negative integers, got ${array[i]}.`);",
        "    }",
        "  }",
        "  let [count, output] = mo_auxArrays(2, BASE);",
        "  lsdSort(array, count, output);",
        "}"
      ]
    },
    {
      "name": "merge",
      "code": [
        "#!main",
        "function merge(array, left, right, start, mid, end) {",
        "  let nl = mid - start + 1, nr = end - mid, i = 0, j = 0, k = start;",
        "  mo_highlight([...mo_range(start, start + nl)], GREEN);",
        "  for (let i = 0; i < nl; i++)",
        "    left[i] = array[i + start];",
        "  mo_highlight([...mo_range(mid + 1, mid + 1 + nr)], GREEN);",
        "  for (let i = 0; i < nr; i++)",
        "    right[i] = array[i + mid + 1];",
        "  for (; i < nl && j < nr; k++) {",
        "    if (left[i] < right[j]) {",
        "      mo_highlight(left, i, RED);",
        "      array[k] = left[i++];",
        "    }",
        "    else {",
        "      mo_highlight(right, j, RED);",
        "      array[k] = right[j++];",
        "    }",
        "  }",
        "  while (nl - i > 0) {",
        "    mo_highlight(left, [...mo_range(i, nl)], GREEN);",
        "    array[k++] = left[i++];",
        "  }",
        "  while (nr - j > 0) {",
        "    mo_highlight(right, [...mo_range(j, nr)], GREEN);",
        "    array[k++] = right[j++];",
        "  }",
        "  mo_clearArray(left, right);",
        "}",
        "function mergeSort(array, left, right, start, end) {",
        "  if (start >= end) return;",
        "  const mid = Math.floor(start + (end - start) / 2);",
        "  mergeSort(array, left, right, start, mid);",
        "  mergeSort(array, left, right, mid + 1, end);",
        "  merge(array, left, right, start, mid, end);",
        "}",
        "function main(array) {",
        "  const [left, right] = mo_auxArrays(2);",
        "  mergeSort(array, left, right, 0, array.length - 1);",
        "}"
      ]
    },
    {
      "name": "msd",
      "code": [
        "#!main",
        "const BASE = 10;",
        "function digit(x, exponent) {",
        "  return Math.floor(x / exponent) % BASE;",
        "}",
        "function countingSort(array, count, output, left, right, exponent) {",
        "  for (let i = left; i <= right; i++) {",
        "    mo_highlight(i, GREEN);",
        "    count[digit(array[i], exponent)]++;",
        "  }",
        "  for (let i = 1; i < count.length; i++) {",
        "    count[i] += count[i - 1];",
        "  }",
        "  for (let i = right; i >= left; i--) {",
        "    output[left + --count[digit(array[i], exponent)]] = array[i];",
        "  }",
        "  for (let i = left; i < right + 1; i++) {",
        "    array[i] = output[i];",
        "  }",
        "  mo_clearArray(count, output);",
        "}",
        "function msdSort(array, count, output, left, right, exponent) {",
        "  if (left >= right || exponent === 0) return;",
        "  mo_clearArray(count);",
        "  countingSort(array, count, output, left, right, exponent);",
        "  for (let i = left; i <= right; i++) {",
        "    count[digit(array[i], exponent)]++;",
        "  }",
        "  mo_highlight(count, [...mo_range(0, count.length)], BLUE);",
        "  for (let v of count.slice()) {",
        "    if (v > 0) {",
        "      msdSort(array, count, output, left, left + v - 1, Math.floor(exponent / BASE));",
        "    }",
        "    left += v;",
        "  }",
        "}",
        "function main(array) {",
        "  let [count, output] = mo_auxArrays(2, BASE);",
        "  let maxNum = Math.max(...array);",
        "  let mostSignificantDigitPlace = Math.pow(BASE, Math.floor(Math.log(maxNum, BASE)));",
        "  msdSort(array, count, output, 0, array.length - 1, mostSignificantDigitPlace);",
        "}"
      ]
    },
    {
      "name": "oddeven",
      "code": [
        "#!oddEvenSort",
        "function bubbleSort(array, even) {",
        "  let sorted = true;",
        "  for (let i = even ? 1 : 2; i < array.length; i += 2) {",
        "    mo_highlight([i - 1, i], GREEN);",
        "    if (array[i - 1] > array[i]) {",
        "      mo_swap(i - 1, i);",
        "      sorted = false;",
        "    }",
        "  }",
        "  return sorted;",
        "}",
        "function oddEvenSort(array) {",
        "  let sorted = false;",
        "  while (!sorted) {",
        "    sorted = bubbleSort(array, false)",
        "      && bubbleSort(array, true);",
        "  }",
        "}"
      ]
    },
    {
      "name": "pancake",
      "code": [
        "#!pancakeSort",
        "function flip(k) {",
        "  mo_highlight([...mo_range(0, k + 1)], BLUE);",
        "  let left = 0;",
        "  while (left < k) {",
        "    mo_swap(left, k);",
        "    k--;",
        "    left++;",
        "  }",
        "}",
        "function max_index(array, k) {",
        "  let index = 0;",
        "  for (let i = 0; i < k; i++) {",
        "    mo_highlight([i, index, k - 1], [GREEN, GREEN, BLUE]);",
        "    if (array[i] > array[index])",
        "      index = i;",
        "  }",
        "  return index;",
        "}",
        "function pancakeSort(array) {",
        "  for (let n = array.length; n > 1; n--) {",
        "    let maxdex = max_index(array, n);",
        "    if (maxdex !== n) {",
        "      flip(maxdex);",
        "      flip(n - 1);",
        "    }",
        "  }",
        "}"
      ]
    },
    {
      "name": "quickllpe",
      "code": [
        "#!main",
        "function partition(array, first, last) {",
        "  mo_mark();",
        "  let pivotIndex = last, lower = first;",
        "  for (let higher = lower; higher <= last - 1; higher++) {",
        "    mo_highlight([lower, higher, pivotIndex], [RED, GREEN, BLUE]);",
        "    if (array[higher] < array[pivotIndex]) {",
        "      mo_swap(lower, higher);",
        "      lower++;",
        "      mo_highlight([lower, higher, pivotIndex], [RED, GREEN, BLUE]);",
        "    }",
        "  }",
        "  mo_swap(lower, pivotIndex);",
        "  mo_highlight([",
        "    ...mo_range(first, lower),",
        "    lower,",
        "    ...mo_range(lower + 1, last + 1)",
        "  ], [",
        "    ...mo_range(first, lower).fill(RED),",
        "    BLUE,",
        "    ...mo_range(lower + 1, last + 1).fill(GREEN)",
        "  ]);",
        "  return lower;",
        "}",
        "function quickSort(array, first, last) {",
        "  if (first >= last) return;",
        "  const pivotIndex = partition(array, first, last);",
        "  quickSort(array, first, pivotIndex - 1);",
        "  quickSort(array, pivotIndex + 1, last);",
        "}",
        "function main(array) {",
        "  quickSort(array, 0, array.length - 1);",
        "}"
      ]
    },
    {
      "name": "quickllps",
      "code": [
        "#!main",
        "function partition(array, first, last) {",
        "  mo_mark();",
        "  let pivotIndex = first, lower = first;",
        "  for (let higher = lower; higher <= last; higher++) {",
        "    mo_highlight([lower, higher, pivotIndex], [RED, GREEN, BLUE]);",
        "    if (array[higher] < array[pivotIndex]) {",
        "      lower++;",
        "      mo_highlight([lower, higher, pivotIndex], [RED, GREEN, BLUE]);",
        "      mo_swap(lower, higher);",
        "    }",
        "  }",
        "  mo_swap(lower, pivotIndex);",
        "  mo_highlight([",
        "    ...mo_range(first, lower),",
        "    lower,",
        "    ...mo_range(lower + 1, last + 1)",
        "  ], [",
        "    ...mo_range(first, lower).fill(RED),",
        "    BLUE,",
        "    ...mo_range(lower + 1, last + 1).fill(GREEN)",
        "  ]);",
        "  return lower;",
        "}",
        "function quickSort(array, first, last) {",
        "  if (first >= last) return;",
        "  const pivotIndex = partition(array, first, last);",
        "  quickSort(array, first, pivotIndex - 1);",
        "  quickSort(array, pivotIndex + 1, last);",
        "}",
        "function main(array) {",
        "  quickSort(array, 0, array.length - 1);",
        "}"
      ]
    },
    {
      "name": "quicklrps",
      "code": [
        "#!main",
        "function partition(array, first, last) {",
        "  mo_mark();",
        "  let pivotIndex = first, lower = first + 1, higher = last;",
        "  while (lower <= higher) {",
        "    for (; lower <= higher && array[lower] < array[pivotIndex]; lower++) {",
        "      mo_highlight([lower, higher, pivotIndex], [RED, GREEN, BLUE]);",
        "    }",
        "    for (; lower <= higher && array[higher] > array[pivotIndex]; higher--) {",
        "      mo_highlight([lower, higher, pivotIndex], [RED, GREEN, BLUE]);",
        "    }",
        "    if (lower <= higher) {",
        "      mo_highlight([lower, higher, pivotIndex], [RED, GREEN, BLUE]);",
        "      mo_swap(lower, higher);",
        "      lower++;",
        "      higher--;",
        "    }",
        "  }",
        "  mo_swap(higher, pivotIndex);",
        "  mo_highlight([",
        "    ...mo_range(first, higher),",
        "    higher,",
        "    ...mo_range(higher + 1, last + 1)",
        "  ], [",
        "    ...mo_range(first, higher).fill(RED),",
        "    BLUE,",
        "    ...mo_range(higher + 1, last + 1).fill(GREEN)",
        "  ]);",
        "  return higher;",
        "}",
        "function quickSort(array, first, last) {",
        "  if (first >= last) return;",
        "  let pivotIndex = partition(array, first, last);",
        "  quickSort(array, first, pivotIndex - 1);",
        "  quickSort(array, pivotIndex + 1, last);",
        "}",
        "function main(array) {",
        "  quickSort(array, 0, array.length - 1);",
        "}"
      ]
    },
    {
      "name": "quicklrpm",
      "code": [
        "#!main",
        "function partition(array, first, last) {",
        "  mo_mark();",
        "  let pivotIndex = Math.floor((first + last) / 2), pivot = array[pivotIndex], lower = first, higher = last;",
        "  while (lower <= higher) {",
        "    for (; lower <= higher && array[lower] < pivot; lower++) {",
        "      mo_highlight([lower, higher, pivotIndex], [RED, GREEN, BLUE]);",
        "    }",
        "    for (; lower <= higher && array[higher] > pivot; higher--) {",
        "      mo_highlight([lower, higher, pivotIndex], [RED, GREEN, BLUE]);",
        "    }",
        "    if (lower <= higher) {",
        "      mo_highlight([lower, higher, pivotIndex], [RED, GREEN, BLUE]);",
        "      mo_swap(lower, higher);",
        "      if (pivotIndex === lower) pivotIndex = higher;",
        "      else if (pivotIndex === higher) pivotIndex = lower;",
        "      lower++;",
        "      higher--;",
        "    }",
        "  }",
        "  mo_highlight([",
        "    ...mo_range(first, pivotIndex),",
        "    pivotIndex,",
        "    ...mo_range(pivotIndex + 1, last + 1)",
        "  ], [",
        "    ...mo_range(first, pivotIndex).fill(RED),",
        "    BLUE,",
        "    ...mo_range(pivotIndex + 1, last + 1).fill(GREEN)",
        "  ]);",
        "  return lower;",
        "}",
        "function quickSort(array, first, last) {",
        "  if (first >= last) return;",
        "  let pivotIndex = partition(array, first, last);",
        "  quickSort(array, first, pivotIndex - 1);",
        "  quickSort(array, pivotIndex, last);",
        "}",
        "function main(array) {",
        "  quickSort(array, 0, array.length - 1);",
        "}"
      ]
    },
    {
      "name": "quicklrpe",
      "code": [
        "#!main",
        "function partition(array, first, last) {",
        "  mo_mark();",
        "  let pivotIndex = last, lower = first, higher = last - 1;",
        "  while (lower <= higher) {",
        "    for (; lower <= higher && array[lower] < array[pivotIndex]; lower++) {",
        "      mo_highlight([lower, higher, pivotIndex], [RED, GREEN, BLUE]);",
        "    }",
        "    for (; lower <= higher && array[higher] > array[pivotIndex]; higher--) {",
        "      mo_highlight([lower, higher, pivotIndex], [RED, GREEN, BLUE]);",
        "    }",
        "    if (lower <= higher) {",
        "      mo_highlight([lower, higher, pivotIndex], [RED, GREEN, BLUE]);",
        "      mo_swap(lower, higher);",
        "      lower++;",
        "      higher--;",
        "    }",
        "  }",
        "  mo_swap(lower, pivotIndex);",
        "  mo_highlight(",
        "    [",
        "      ...mo_range(first, lower),",
        "      lower,",
        "      ...mo_range(lower + 1, last + 1)],",
        "    [",
        "      ...mo_range(first, lower).fill(RED),",
        "      BLUE,",
        "      ...mo_range(lower + 1, last + 1).fill(GREEN)",
        "    ]",
        "  );",
        "  return lower;",
        "}",
        "function quickSort(array, first, last) {",
        "  if (first >= last) return;",
        "  let pivotIndex = partition(array, first, last);",
        "  quickSort(array, first, pivotIndex - 1);",
        "  quickSort(array, pivotIndex + 1, last);",
        "}",
        "function main(array) {",
        "  quickSort(array, 0, array.length - 1);",
        "}"
      ]
    },
    {
      "name": "selection",
      "code": [
        "#!selectionSort",
        "function findMin(array, first, last) {",
        "  let mini = first;",
        "  for (let i = first + 1; i <= last; i++) {",
        "    mo_highlight([mini, i, first], [GREEN, RED, BLUE]);",
        "    if (array[i] < array[mini]) mini = i;",
        "  }",
        "  return mini;",
        "}",
        "function selectionSort(array) {",
        "  for (let i = 0; i < array.length - 1; i++) {",
        "    mo_mark();",
        "    let mini = findMin(array, i, array.length - 1);",
        "    if (mini != i) mo_swap(mini, i);",
        "  }",
        "}"
      ]
    },
    {
      "name": "shell",
      "code": [
        "#!shellSort",
        "function insertionSort(array, i, gap) {",
        "  mo_highlight(i, BLUE);",
        "  let j, oldValue = array[i];",
        "  for (j = i; j >= gap; j -= gap) {",
        "    mo_highlight([j - gap, j], GREEN);",
        "    if (array[j - gap] > oldValue) {",
        "      array[j] = array[j - gap];",
        "    }",
        "    else break;",
        "  }",
        "  array[j] = oldValue;",
        "}",
        "function shellSort(array) {",
        "  for (",
        "    let gap = Math.floor(array.length / 2);",
        "    gap > 0;",
        "    gap = Math.floor(gap / 2)",
        "  ) {",
        "    for (let i = gap; i < array.length; i++) {",
        "      insertionSort(array, i, gap);",
        "    }",
        "  }",
        "}"
      ]
    },
    {
      "name": "stooge",
      "code": [
        "#!main",
        "function stoogeSort(arr, l, h) {",
        "  if (l >= h) return;",
        "  mo_highlight([l, h], GREEN);",
        "  if (arr[l] > arr[h])",
        "    mo_swap(l, h);",
        "  if (h - l + 1 > 2) {",
        "    let t = Math.floor((h - l + 1) / 3);",
        "    stoogeSort(arr, l, h - t);",
        "    stoogeSort(arr, l + t, h);",
        "    stoogeSort(arr, l, h - t);",
        "  }",
        "}",
        "function main(array) {",
        "  stoogeSort(array, 0, array.length - 1);",
        "}"
      ]
    },
    {
      "name": "tim",
      "code": [
        "#!main",
        "const RUN = 32;",
        "function insertionSort(array, first, last) {",
        "  for (let i = first + 1; i <= last; i++) {",
        "    mo_highlight(i, BLUE);",
        "    let j, oldValue = array[i];",
        "    for (j = i; j > first; j--) {",
        "      mo_highlight([j - 1, j], GREEN);",
        "      if (array[j - 1] > oldValue)",
        "        array[j] = array[j - 1];",
        "      else break;",
        "    }",
        "    array[j] = oldValue;",
        "  }",
        "}",
        "function merge(array, left, right, start, mid, end) {",
        "  let nl = mid - start + 1, nr = end - mid, i = 0, j = 0, k = start;",
        "  mo_highlight([...mo_range(start, start + nl)], GREEN);",
        "  for (let i = 0; i < nl; i++)",
        "    left[i] = array[i + start];",
        "  mo_highlight([...mo_range(mid + 1, mid + 1 + nr)], GREEN);",
        "  for (let i = 0; i < nr; i++)",
        "    right[i] = array[i + mid + 1];",
        "  for (; i < nl && j < nr; k++) {",
        "    if (left[i] < right[j]) {",
        "      mo_highlight(left, i, RED);",
        "      array[k] = left[i++];",
        "    }",
        "    else {",
        "      mo_highlight(right, j, RED);",
        "      array[k] = right[j++];",
        "    }",
        "  }",
        "  while (nl - i > 0) {",
        "    mo_highlight(left, [...mo_range(i, nl)], GREEN);",
        "    array[k++] = left[i++];",
        "  }",
        "  while (nr - j > 0) {",
        "    mo_highlight(right, [...mo_range(j, nr)], GREEN);",
        "    array[k++] = right[j++];",
        "  }",
        "  mo_clearArray(left, right);",
        "}",
        "function timSort(array, left, right) {",
        "  for (let i = 0; i < array.length; i += RUN) {",
        "    insertionSort(array, i, Math.min(i + RUN - 1, array.length - 1));",
        "  }",
        "  for (let size = RUN; size < array.length; size *= 2) {",
        "    for (let start = 0; start < array.length; start += size * 2) {",
        "      let mid = start + size - 1,",
        "        end = Math.min(start + size * 2 - 1, array.length - 1);",
        "      if (mid < end)",
        "        merge(array, left, right, start, mid, end);",
        "    }",
        "  }",
        "}",
        "function main(array) {",
        "  const [l, r] = mo_auxArrays(2);",
        "  timSort(array, l, r);",
        "}"
      ]
    }
  ]
}
